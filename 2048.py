# John Loeber | Python 2.7.8 | 15-Nov-2014 | www.johnloeber.com

from copy import deepcopy
from random import randint
from os.path import expanduser, isfile
import locale
import sys
import curses

# path to file where we store the max score
SCORE_FILE_PATH = expanduser("~/.2048.txt")

KEY_OPTS = {
    curses.KEY_DOWN:  "down",
    curses.KEY_RIGHT: "right",
    curses.KEY_LEFT:  "left",
    curses.KEY_UP:    "up",
    ord('Q'):         "quit",
    ord('q'):         "quit",
    ord('h'):         "left",
    ord('H'):         "left",
    ord('j'):         "down",
    ord('J'):         "down",
    ord('k'):         "up",
    ord('K'):         "up",
    ord('l'):         "right",
    ord('L'):         "right",
    ord('t'):         "try-again",
    ord('T'):         "try-again",
}

MAX_SCORE_MESSAGE = (
    "This file was generated by 2048.py. It keeps track of your "
    "max score in the command-line 2048 game. For documentation, see"
    " http://www.johnloeber.com/docs/2048.html.\n"
)

def get_max_score():
    """
    retrieve max score from the score-file
    """
    try:
        with open(SCORE_FILE_PATH, "r") as f:
            return f.readlines()[1].rstrip('\n')
    except:
        # if the score-file is somehow corrupted or does not exist, create a new one
        write_max_score("0")
        return "0"

def write_max_score(score):
    """
    write max score to the score-file=
    """
    with open(SCORE_FILE_PATH, "w") as f:
        return f.write(MAX_SCORE_MESSAGE + score)

def get_move():
    """
    get the player's next move.
    if the move is invalid, flash an error to the game screen.
    """
    global stdscr
    while True:
        char = stdscr.getch()
        command = KEY_OPTS.get(char)
        if char in KEY_OPTS:
            return command
        else:
            stdscr.addstr(11, 5, "Not an arrow key! Try again.")
            stdscr.refresh()

def another_game():
    """
    when the game is over, ask the player if they want another game.
    """
    global stdscr
    stdscr.move(10, 0)
    stdscr.clrtoeol()
    stdscr.addstr(10, 5, "Game Over! Press 't' to try again.")
    stdscr.refresh()
    while True:
        char = stdscr.getch()
        command = KEY_OPTS.get(char)
        if command == "quit":
            stop()
        elif command == 'try-again':
            return True

class Game(object):
    """
    represents a 2048 game board
    """

    def __init__(self):
        self.board = []
        self.win = False
        self.new_coord = []
        self.max_score = get_max_score()
        self.score = "0"

        self.make_blank_board()
        return

    def make_blank_board(self):
        """
        creates a blank game board, spawns initial two digits
        """
        self.board = [''] * 16
        self.spawn()
        self.spawn()
        return

    def get_score(self):
        """
        computes the score on the board, returns it as a string.
        """
        return str(sum(int(x) for x in [y for y in self.board if y != '']))

    def update_score(self):
        """
        retrieve the current score, compare it to the max score, update if necessary.
        """
        self.score = self.get_score()
        if int(self.score) > int(self.max_score):
            write_max_score(self.score)
            self.max_score = self.score
        return

    def display(self):
        """
        prints the current board to the screen.
        there are marginally more efficient ways we could do this: e.g. not
        clear the entire screen but rather just refresh certain characters.
        """
        global stdscr
        stdscr.erase()
        stdscr.addstr(2, 5, "Documentation is at www.johnloeber.com/docs/2048.html."
                            "\n     Press 'q' to quit.")

        # create the strings to represent the current items on the board
        max_len = max(len(i) for i in self.board)
        board_copy = deepcopy(self.board)
        for index, board_item in enumerate(board_copy):
            board_copy[index] = "[" + (" " * (max_len - len(board_item))) + board_item + "] "

        # print those strings to the screen
        board_indices = [[0, 1, 2, 3],
                         [4, 5, 6, 7],
                         [8, 9, 10, 11],
                         [12, 13, 14, 15]]
        for row_index, row in enumerate(board_indices):
            to_write = ""
            for cell_index in row:
                to_write += board_copy[cell_index]
            stdscr.addstr(row_index+5, 5, to_write)

        # writes the new coordinates in bold, over the current board.
        for i in self.new_coord:
            row = i / 4
            entry = (i % 4) * len(board_copy[i])
            stdscr.addstr(row+5, entry+5, board_copy[i], curses.A_BOLD)

        # if the user has won, write a congratulatory message
        if self.win:
            win_message = "Congratulations, you win! Keep playing if you wish."
            stdscr.addstr(10, 5, win_message)

        # write the current and max scores
        stdscr.addstr(3, 46 - len(self.max_score), "Best Score: " + self.max_score)
        stdscr.addstr(4, 43 - len(self.score), "Current Score: " + self.score)

        stdscr.refresh()
        return

    def spawn(self):
        """
        spawn a new integer on the board.
        """
        if '' in self.board:
            empty_indices = [index for index, cell in enumerate(self.board) if cell == '']
            random_loc = randint(0, len(empty_indices)-1)
            # one-in-ten chance of getting a '4' instead of a '2'
            chance = randint(1, 10)
            if chance == 10:
                self.board[empty_indices[random_loc]] = '4'
            else:
                self.board[empty_indices[random_loc]] = '2'
            self.new_coord.append(empty_indices[random_loc])
        return

    def has_lost(self):
        """
        returns True if the user has lost.
        """
        # if a square is empty, then the game is still going on.
        if '' in self.board:
            return

        possible_moves = ["up", "down", "left", "right"]
        next_possible_game_states = [newboard(self.board, move) for move in possible_moves]
        # if all next possible game states are the same as the current, then game over.
        if all(game_state == self.board for game_state in next_possible_game_states):
            return True
        else:
            return False

def strip(items):
    """
    newboard helper:
    filters a list, returns the items that aren't the empty string, in order.
    """
    return [item for item in items if item != '']

def weave(list1, list2, list3, list4):
    """
    newboard helper:
    no idea.
    """
    x = []
    for i in range(0, 4):
        for j in [list1, list2, list3, list4]:
            x.append(j[i])
    return x

def fill(l):
    """
    newboard helper.
    no idea.
    """
    if len(l)<4:
        l += ['']*(4-len(l))
    return l

def newboard(board,move):
    # process a move, and return the consequent state of the board.
    if move=="quit":
        stop()
    elif move=="up" or move=="down":
        parts = [[board[0],board[4],board[8],board[12]],
                 [board[1],board[5],board[9],board[13]],
                 [board[2],board[6],board[10],board[14]],
                 [board[3],board[7],board[11],board[15]]]
    else:
        parts = [board[0:4],
                 board[4:8],
                 board[8:12],
                 board[12:16]]
    # i'll be "folding" the sublists, so i'm now arranging them to have them
    # cascade properly.
    if move=="down" or move=="right":
        for x in range(len(parts)):
            parts[x] = parts[x][::-1]
            # all folds will go left (or up), hence the need to reverse lists
    newparts = [[],[],[],[]]
    # and here the cascading fold begins.
    for i in range(4):
        newl = strip(parts[i])
        if len(newl)==0:
            continue
        elif len(newl)==1:
            newparts[i].append(newl[0])
        elif len(newl)==2:
            if newl[0]==newl[1]:
                newparts[i].append(str(int(newl[0])+int(newl[1])))
            else:
                newparts[i].append(newl[0])
                newparts[i].append(newl[1])
        elif len(newl)==3:
            if newl[0]==newl[1]:
                newparts[i].append(str(int(newl[0])+int(newl[1])))
                newparts[i].append(newl[2])
            else:
                newparts[i].append(newl[0])
                if newl[1]==newl[2]:
                    newparts[i].append(str(int(newl[1])+int(newl[2])))
                else:
                    newparts[i].append(newl[1])
                    newparts[i].append(newl[2])
        else:
            if newl[0]==newl[1]:
                newparts[i].append(str(int(newl[0])+int(newl[1])))
                if newl[2]==newl[3]:
                    newparts[i].append(str(int(newl[2])+int(newl[3])))
                else:
                    newparts[i].append(newl[2])
                    newparts[i].append(newl[3])
            else:
                newparts[i].append(newl[0])
                if newl[1]==newl[2]:
                    newparts[i].append(str(int(newl[1])+int(newl[2])))
                    newparts[i].append(newl[3])
                else:
                    newparts[i].append(newl[1])
                    if newl[2]==newl[3]:
                        newparts[i].append(str(int(newl[2])+int(newl[3])))
                    else:
                        newparts[i].append(newl[2])
                        newparts[i].append(newl[3])
    for x in range(4):
        newparts[x] = fill(newparts[x])
    if move=="up":
        return weave(newparts[0],newparts[1],newparts[2],newparts[3])
    elif move=="down":
        return weave(newparts[0][::-1],newparts[1][::-1],newparts[2][::-1],newparts[3][::-1])
    elif move=="right":
        return newparts[0][::-1] + newparts[1][::-1] + newparts[2][::-1] + newparts[3][::-1]
    else:
        return [x for sublist in newparts for x in sublist]

def stop():
    """
    end the game and exit.
    """
    sys.exit(0)

def game_loop():
    """
    self-explanatory
    """
    while True:
        # this loop allows multiple games
        game = Game()

        while True:
            # this loop allows multiple moves within one game
            game.display()
            game.new_coord = []

            if game.has_lost():
                if another_game():
                    # returns us to the upper-level game loop
                    break

            new_board = game.board
            while (new_board == game.board):
                # get new moves until one of them actually changes the game state
                move = get_move()
                if move == "quit":
                    stop()
                elif move == "try-again":
                    continue
                else:
                    new_board = newboard(game.board, move)

            game.board = new_board

            # once state has changed, spawn new int
            game.spawn()

            if "2048" in game.board:
                game.win = True

            game.update_score()

def main(screen):
    locale.setlocale(locale.LC_ALL, '')
    global stdscr
    stdscr=curses.initscr()
    curses.cbreak()
    stdscr.keypad(1)
    curses.curs_set(0)
    game_loop()

if __name__ == '__main__':
    curses.wrapper(main)
