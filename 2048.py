# John Loeber | Python 2.7.8 | 15-NOV-2014 | www.johnloeber.com
# Mostly written in March 2014, hence dubious stylistic choices

from copy import deepcopy
from random import randint
from os.path import expanduser
import sys,curses

# retrieve max score from the store-file
def getmaxscore():
    try:
        with open(expanduser("~/.2048.txt"),"r") as f:
            return f.readlines()[1].rstrip('\n')
    except:
        return "0"

# write max score to the store-file
def writemaxscore(n):
    # Can do this w/o rewriting msg every time. Not important on this scale.
    message = ("This file was generated by 2048.py. It keeps track of your "
               "max score in the command-line 2048 game. For documentation, see"
               " http://www.johnloeber.com/docs/2048.html.\n")
    try:
        with open(expanduser("~/.2048.txt"),"w") as f:
            f.write(message+str(n))
    except:
        return

def printboard(b):
    global newcoord,stdscr,win
    # clearing the window is inefficient, but that's not a concern on this scale
    stdscr.erase()
    stdscr.addstr(2,5,"Documentation is at www.johnloeber.com/docs/2048.html."
                  "\n     Press 'q' to quit.")
    maxlen = max([len(i) for i in b])
    c = deepcopy(b)
    for l in range(len(c)):
        c[l] = "[" + " "*(maxlen-len(c[l])) + c[l] + "]" + " "
    # writes the current board
    for index,k in enumerate([[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15]]):
        towrite = ""
        for j in k:
            towrite += c[j]
        stdscr.addstr(index+5,5,towrite)
    # writes the new coordinates in bold, over the current board.
    for i in newcoord:
        row = i/4
        entry = (((i%4))*len(c[i]))
        stdscr.addstr(row+5,entry+5,c[i],curses.A_BOLD)    
    if win:
        msg = "Congratulations, you win! Keep playing if you wish."
        stdscr.addstr(10,5,msg)
    # gets the maxscore, compares it to the current score, etc.
    maxscore = getmaxscore()
    score = getscore(b)
    if int(score) > int(maxscore):
            writemaxscore(score)
            maxscore = score
    # writes scores
    stdscr.addstr(3,46-len(maxscore),"Best Score: " +maxscore)
    stdscr.addstr(4,43-len(score),"Current Score: " +score)
    stdscr.refresh()
    # reset newcoords for next iteration in game loop
    newcoord = []
    return

# spawns a new integer
def spawn(b):
    if '' in b:
        global newcoord
        empties = [a for a in range(len(b)) if b[a]=='']
        loc = randint(0,len(empties)-1)
        chance = randint(1,10)
        # edit here if you only want twos to appear
        if chance==10:      
            b[empties[loc]]='4' 
        else:
            b[empties[loc]]='2' 
        newcoord.append(empties[loc])
        return b 

# fetches the next move from the user
def getmove():
        global stdscr
        i = stdscr.getch()
        # mapping key inputs to actions. also supports vim keys.
        opts = {curses.KEY_DOWN:"down",curses.KEY_RIGHT:"right",ord('Q'):"quit",
                curses.KEY_LEFT:"left",curses.KEY_UP:"up",ord('q'):"quit",
                ord('h'):"left",ord('H'):"left",ord('j'):"down",ord('J'):"down",
                ord('k'):"up",ord('K'):"up",ord('l'):"right",ord('L'):"right"}
        try:
            return opts[i]
        except:
            stdscr.addstr(11,5,"Not an arrow key! Try again.")
            stdscr.refresh()
            getmove()

# helper for newboard
def strip(l):
    return [i for i in l if i!='']

# helper for newboard
def weave(l1,l2,l3,l4):
    x = []
    for i in range(0,4):
        for j in [l1,l2,l3,l4]:
            x.append(j[i])
    return x    

# helper for newboard
def fill(l):
    if len(l)<4:
        l += ['']*(4-len(l))
    return l

# This is particularly ugly. I wrote it some months ago. It seems inelegant,
# but folding the list correctly is actually a remarkably difficult task
# given the number of edge cases and particularities. Consequently, I wrote 
# this bruteforce function to just get the job done -- writing a nice, higher-
# level reduce-type function to do this proved difficult. I think the ugliness
# of this function stems from my choice of data structure (flat list) for the
# board, which was probably a mistake. A class-based structure would allow
# for a more elegant solution and handling of new moves.
def newboard(board,move):
    # process a move, and return the consequent state of the board.
    if move=="quit":
        stop()
    elif move=="up" or move=="down":
        parts = [[board[0],board[4],board[8],board[12]],
                 [board[1],board[5],board[9],board[13]],
                 [board[2],board[6],board[10],board[14]],
                 [board[3],board[7],board[11],board[15]]]
    else:
        parts = [board[0:4],
                 board[4:8],
                 board[8:12],
                 board[12:16]]
    # i'll be "folding" the sublists, so i'm now arranging them to have them
    # cascade properly.
    if move=="down" or move=="right":
        for x in range(len(parts)):
            parts[x] = parts[x][::-1]
            # all folds will go left (or up), hence the need to reverse lists
    newparts = [[],[],[],[]]
    # and here the cascading fold begins.
    for i in range(4):
        newl = strip(parts[i])
        if len(newl)==0:
            continue
        elif len(newl)==1:
            newparts[i].append(newl[0])
        elif len(newl)==2:
            if newl[0]==newl[1]:
                newparts[i].append(str(int(newl[0])+int(newl[1])))
            else:
                newparts[i].append(newl[0])
                newparts[i].append(newl[1])
        elif len(newl)==3:
            if newl[0]==newl[1]:
                newparts[i].append(str(int(newl[0])+int(newl[1])))
                newparts[i].append(newl[2])
            else:
                newparts[i].append(newl[0])
                if newl[1]==newl[2]:
                    newparts[i].append(str(int(newl[1])+int(newl[2])))
                else:
                    newparts[i].append(newl[1])
                    newparts[i].append(newl[2])
        else:
            if newl[0]==newl[1]:
                newparts[i].append(str(int(newl[0])+int(newl[1])))
                if newl[2]==newl[3]:
                    newparts[i].append(str(int(newl[2])+int(newl[3])))
                else:
                    newparts[i].append(newl[2])
                    newparts[i].append(newl[3])
            else:
                newparts[i].append(newl[0])
                if newl[1]==newl[2]:
                    newparts[i].append(str(int(newl[1])+int(newl[2])))
                    newparts[i].append(newl[3])
                else:
                    newparts[i].append(newl[1])
                    if newl[2]==newl[3]:
                        newparts[i].append(str(int(newl[2])+int(newl[3])))
                    else:
                        newparts[i].append(newl[2])
                        newparts[i].append(newl[3])
    for x in range(4):
        newparts[x] = fill(newparts[x])
    if move=="up":
        return weave(newparts[0],newparts[1],newparts[2],newparts[3])
    elif move=="down":
        return weave(newparts[0][::-1],newparts[1][::-1],newparts[2][::-1],newparts[3][::-1])
    elif move=="right":
        return newparts[0][::-1] + newparts[1][::-1] + newparts[2][::-1] + newparts[3][::-1]    
    else:
        return [x for sublist in newparts for x in sublist]

# given a board, returns the score
def getscore(b):
    return str(sum(int(x) for x in [y for y in b if y!='']))

# end the application
def stop():
    # undo all curses-stuff
    global stdscr
    stdscr.keypad(0)
    curses.nocbreak()
    curses.curs_set(1)
    curses.endwin()
    sys.exit(0)
    return

# check if the user has lost
def check(b):
    # if a square is empty, the game's obviously still on...
    if '' in b:
        return
    possible = [newboard(b,y) for y in ["up","down","left","right"]]
    # if all next possible game states are the same as the current, 
    # then the game is over.
    if possible.count(b)==4:
        global stdscr
        stdscr.move(10,0)
        stdscr.clrtoeol()
        stdscr.addstr(10,5,"Game Over! Press 't' to try again.")
        stdscr.refresh()
        while True:
            c = stdscr.getch()
            if c not in [ord('q'),ord('Q'),ord('t'),ord('T')]:
                continue
            else:
                # this syntactic choice to avoid memory leaks (nested games)
                break
        if c==ord('q') or c==ord('Q'):
            stop()
        elif c==ord('t') or c==ord('T'):
            game()

def game():
    # initialize a new game
    global newcoord,stdscr,win,maxscore
    newcoord = []
    win = False
    board = spawn(spawn(['']*16))
    printboard(board)
    # game loop
    while True:
        check(board)
        board2 = board
        # so user submits keypresses that change the state of the game
        while(board2==board):
            move = getmove()            
            board2 = newboard(board,move)
        # once state has changed, spawn new int
        board2 = spawn(board2)
        if "2048" in board2:
            win = True
        printboard(board2)
        board = board2

def main(screen):
    # initialize curses-stuff
    global stdscr
    stdscr=curses.initscr()
    curses.cbreak()
    stdscr.keypad(1)
    curses.curs_set(0)    
    game()
    
if __name__=='__main__':
    curses.wrapper(main)
