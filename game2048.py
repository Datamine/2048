"""
2048 game for the command line.
John Loeber | Python 2.7.8 | 15-Nov-2014 | contact@johnloeber.com
"""
from copy import deepcopy
from random import randint
from os.path import expanduser
import locale
import sys
import curses
from math import sqrt

# path to file where we store the max score
SCORE_FILE_PATH = expanduser("~/.2048.txt")

KEY_OPTS = {
    curses.KEY_DOWN:  "down",
    curses.KEY_RIGHT: "right",
    curses.KEY_LEFT:  "left",
    curses.KEY_UP:    "up",
    ord('Q'):         "quit",
    ord('q'):         "quit",
    ord('h'):         "left",
    ord('H'):         "left",
    ord('j'):         "down",
    ord('J'):         "down",
    ord('k'):         "up",
    ord('K'):         "up",
    ord('l'):         "right",
    ord('L'):         "right",
    ord('t'):         "try-again",
    ord('T'):         "try-again",
}

MAX_SCORE_MESSAGE = (
    "This file was generated by 2048.py. It keeps track of your "
    "max score in the command-line 2048 game. For documentation, see"
    " http://www.johnloeber.com/docs/2048.html.\n"
)

def get_max_score():
    """
    retrieve max score from the score-file
    """
    try:
        with open(SCORE_FILE_PATH, "r") as score_file:
            return score_file.readlines()[1].rstrip('\n')
    except:
        # if the score-file is somehow corrupted or does not exist, create a new one
        write_max_score("0")
        return "0"

def write_max_score(score):
    """
    write max score to the score-file=
    """
    with open(SCORE_FILE_PATH, "w") as score_file:
        return score_file.write(MAX_SCORE_MESSAGE + score)

def get_move(screen):
    """
    get the player's next move.
    if the move is invalid, flash an error to the game screen.
    """
    while True:
        char = screen.getch()
        command = KEY_OPTS.get(char)
        if char in KEY_OPTS:
            return command
        else:
            screen.addstr(11, 5, "Not an arrow key! Try again.")
            screen.refresh()

def another_game(screen):
    """
    when the game is over, ask the player if they want another game.
    """
    screen.move(10, 0)
    screen.clrtoeol()
    screen.addstr(10, 5, "Game Over! Press 't' to try again.")
    screen.refresh()
    while True:
        char = screen.getch()
        command = KEY_OPTS.get(char)
        if command == "quit":
            stop()
        elif command == 'try-again':
            return True

class Game(object):
    """
    represents a 2048 game board
    """

    def __init__(self, screen):
        self.board = []
        self.win = False
        self.new_coord = []
        self.max_score = get_max_score()
        self.score = "0"
        self.screen = screen

        self.make_blank_board()
        return

    def make_blank_board(self):
        """
        creates a blank game board, spawns initial two digits
        """
        self.board = [''] * 16
        self.spawn()
        self.spawn()
        return

    def get_score(self):
        """
        computes the score on the board, returns it as a string.
        """
        return str(sum(int(x) for x in [y for y in self.board if y != '']))

    def update_score(self):
        """
        retrieve the current score, compare it to the max score, update if necessary.
        """
        self.score = self.get_score()
        if int(self.score) > int(self.max_score):
            write_max_score(self.score)
            self.max_score = self.score
        return

    def display(self):
        """
        prints the current board to the screen.
        there are marginally more efficient ways we could do this: e.g. not
        clear the entire screen but rather just refresh certain characters.
        """
        self.screen.erase()
        self.screen.addstr(
            2, 5,
            "Documentation is at www.johnloeber.com/docs/2048.html."
            "\n     Press 'q' to quit."
        )

        # create the strings to represent the current items on the board
        max_len = max(len(i) for i in self.board)
        board_copy = deepcopy(self.board)
        for index, board_item in enumerate(board_copy):
            board_copy[index] = "[" + (" " * (max_len - len(board_item))) + board_item + "] "

        # print those strings to the screen
        board_indices = [[0, 1, 2, 3],
                         [4, 5, 6, 7],
                         [8, 9, 10, 11],
                         [12, 13, 14, 15]]
        for row_index, row in enumerate(board_indices):
            to_write = ""
            for cell_index in row:
                to_write += board_copy[cell_index]
            self.screen.addstr(row_index+5, 5, to_write)

        # writes the new coordinates in bold, over the current board.
        for i in self.new_coord:
            row = i / 4
            entry = (i % 4) * len(board_copy[i])
            self.screen.addstr(row+5, entry+5, board_copy[i], curses.A_BOLD)

        # if the user has won, write a congratulatory message
        if self.win:
            win_message = "Congratulations, you win! Keep playing if you wish."
            self.screen.addstr(10, 5, win_message)

        # write the current and max scores
        self.screen.addstr(3, 46 - len(self.max_score), "Best Score: " + self.max_score)
        self.screen.addstr(4, 43 - len(self.score), "Current Score: " + self.score)

        self.screen.refresh()
        return

    def spawn(self):
        """
        spawn a new integer on the board.
        """
        if '' in self.board:
            empty_indices = [index for index, cell in enumerate(self.board) if cell == '']
            random_loc = randint(0, len(empty_indices)-1)
            # one-in-ten chance of getting a '4' instead of a '2'
            chance = randint(1, 10)
            if chance == 10:
                self.board[empty_indices[random_loc]] = '4'
            else:
                self.board[empty_indices[random_loc]] = '2'
            self.new_coord.append(empty_indices[random_loc])
        return

    def has_lost(self):
        """
        returns True if the user has lost, False otherwise.
        """
        # if a square is empty, then the game is still going on.
        if '' in self.board:
            return

        possible_moves = ["up", "down", "left", "right"]
        next_possible_game_states = [newboard(self.board, move) for move in possible_moves]
        # if all next possible game states are the same as the current, then game over.
        return all(game_state == self.board for game_state in next_possible_game_states)

def strip(items):
    """
    newboard helper:
    filters a list, returns the items that aren't the empty string, in order.
    """
    return [item for item in items if item != '']

def weave(list1, list2, list3, list4):
    """
    newboard helper: collapses a list of columns into a flat, row-order list.
    """
    return_list = []
    for i in xrange(0, 4):
        for column in [list1, list2, list3, list4]:
            return_list.append(column[i])
    return return_list

def fill(list_):
    """
    newboard helper: pads a list with extra empty strings until its length is 4.
    """
    list_ += [''] * (4 - len(list_))
    return list_

def newboard(board, move):
    """
    process a move, return the resultant board.
    """
    # convert given board to 2d representation
    width = int(sqrt(len(board)))
    nboard = [[] for i in xrange(width)]
    for i in xrange(len(board)):
        nboard[i%width].append(board[i])
    board = nboard
    height = len(board[0])
    # assign direction vectors and starting points for traversals
    if move == "up":
        direc = (0,1)
        spoints = [(x,0) for x in xrange(len(board))]
    elif move == "down":
        direc = (0,-1)
        spoints = [(x,height-1) for x in xrange(len(board))]
    elif move == "left":
        direc = (1,0)
        spoints = [(0,y) for y in xrange(len(board[0]))]
    elif move == "right":
        direc = (-1,0)
        spoints = [(width-1, y) for y in xrange(len(board[0]))]
    else:
        raise RunTimeException("bad move '{0}' handed to newboard".format(move))
    # perform a traversal for each row or column
    for currpos in spoints:
        # collect a list of every coordinate in the row/column
        vec = []
        while inboard(board, *currpos):
            vec.append(currpos)
            currpos = (currpos[0]+direc[0], currpos[1]+direc[1])
        # collect all the non-zero numbers in the row
        vals = [board[c[0]][c[1]] for c in vec if board[c[0]][c[1]] != ""]
        # squish tiles together, but be careful to
        # only do it once per block
        i = 0
        while i < len(vals)-1:
            if vals[i] == vals[i+1] and vals[i] != "":
                vals[i] = str(2*int(vals[i]))
                del vals[i+1]
            i += 1
        # all the numbers slide the maximum amount, so we
        # fill with empty tiles at the end
        vals = vals + [""] * (width-len(vals))
        for val, coord in zip(vals, vec):
            board[coord[0]][coord[1]] = val
    # translate back to 1d form
    rboard = []
    for y in xrange(height):
        for x in xrange(width):
            rboard.append(board[x][y])
    return rboard

def inboard(board, x, y):
    if x < 0 or y < 0:
        return False
    try:
        board[x][y]
        return True
    except IndexError:
        return False

def stop():
    """
    end the game and exit.
    """
    sys.exit(0)

def game_loop(screen):
    """
    handles gameplay
    """

    # hide the cursor
    curses.curs_set(0)

    while True:
        # this loop allows multiple games
        game = Game(screen)

        while True:
            # this loop allows multiple moves within one game
            game.display()
            game.new_coord = []

            if game.has_lost():
                if another_game(screen):
                    # returns us to the upper-level game loop
                    break

            new_board = game.board
            while (new_board == game.board):
                # get new moves until one of them actually changes the game state
                move = get_move(screen)
                if move == "quit":
                    stop()
                elif move == "try-again":
                    continue
                else:
                    new_board = newboard(game.board, move)

            game.board = new_board

            # once state has changed, spawn new int
            game.spawn()

            if "2048" in game.board:
                game.win = True

            game.update_score()

if __name__ == '__main__':
    locale.setlocale(locale.LC_ALL, '')
    curses.wrapper(game_loop)
